\ifnum\value{code}=1
	\subsection{packages utilisés}
	\begin{minted}[linenos=true, mathescape=true, frame=single, breaklines]{R}
    # ——— install ——— #
    install.packages(c("data.table","wavethresh","fda", "fda.usc"))
    # ——— general packages ——— #
    library(data.table)
    # ——— FDA packages ——— #
    library(fda)
    library(fda.usc)
    # ——— Wavelet packages ——— #
    library(wavethresh)
\end{minted}

\subsection{Simulation des FAR}

\subsubsection{code d'une simulation de monte-carlo}

\begin{minted}[linenos=true, mathescape=false, frame=single, breaklines]{R}
simulation_far_lambda_mc <- far.sim(
    N = N,
    lambda = lambda,
    distribution = runif, 
    hurst = chosen_hurst, 
    kernel = autoregressive_kernel,
    L = 1,
    mu = mu_simul,
    burnin = 100,
    remove_burnin = TRUE,
    G = 100,
    t_vector = seq(from = 0.3, to = 0.8, length.out = 6),
    delta_vector = seq(1e-2, 2e-1, length.out = 30),
    mc = mc_index
)
\end{minted}

\subsubsection{Points utilisés pour la simulation}

\begin{minted}[linenos=true, mathescape=false, frame=single, breaklines]{R}
# random design
points_list <- random_design(N = n, lambda = lambda, distribution = distribution)
# les points où on génère le mfBm
times <- c(points_list[[x]], grid, t_dt[, t1], t_dt[, t2], t_dt[, t3])
# identification des points : observé / grille integrale / comparaison lissage
fac <- as.factor(c(
    rep("observed", length(points_list[[x]])), rep("integral_grid", G),
    rep("t1", n_delta * m), rep("t2", n_delta * m), rep("t3", n_delta * m)
))
# identification de t1,t2,t3
t_index_fac <- as.factor(c(
    rep(NA, length(points_list[[x]])), rep(NA, G),
    rep(t_dt[, t_index], 3)
))
# quelle valeur de delta le t1,t3 correspondent
delta_index_fac <- as.factor(c(
    rep(NA, length(points_list[[x]])), rep(NA, G),
    rep(t_dt[, delta_index], 3)
))
# les points où on simule, identifiés :
df <- data.table(times = times, fac = fac, t_index = t_index_fac, delta_index = delta_index_fac)
\end{minted}

\subsubsection{Innovations : mfBm}

\begin{minted}[linenos=true, mathescape=false, frame=single, breaklines]{R}
X[[i]]$eps <- mfBm.sim(times[[i]]$times, hurst, L)
\end{minted}

\subsubsection{Relation FAR}

\begin{minted}[linenos=true, mathescape=false, frame=single, breaklines]{R}
X[[1]]$X <- X[[1]]$mu + X[[1]]$eps
for (i in 2:n) {
    times <- X[[i]]$times
    Xold <- X[[i - 1]]$X[X[[i - 1]]$fac == "integral_grid"] - X[[i - 1]]$mu[X[[i - 1]]$fac == "integral_grid"]
    Enew <- X[[i]]$eps
    tmp <- expand.grid(s = times, t = grid)
    s <- tmp$s
    t <- tmp$t
    beta <- matrix(kernel(s, t), ncol = G, byrow = FALSE)
    X[[i]]$X <- X[[i]]$mu + as.numeric((1 / G) * beta %*% matrix(Xold, ncol = 1) + Enew)
}
\end{minted}

\section{Lissage des courbes}


\begin{minted}[linenos=true, mathescape=false, frame=single, breaklines]{R}
...
\end{minted}



\section{Détermination de la régularité locale}

\begin{minted}[linenos=true, mathescape=true, frame=single, breaklines]{R}
get_reg_dt <- function(sm_dt) {
    sm_dt <- sm_dt[!(is.nan(xt1) | is.nan(xt2) | is.nan(xt3))]
    reg_dt <- rbindlist(
        lapply(
        split(sm_dt, by = c("delta_index", "t2")),
        function(dt) {
                # $\frac{1}{N}\sum_i \left[ \widehat{X}(v) - \widehat{X}(u) \right]^2$
                res <- dt[, lapply(.((xt1 - xt2)^2, (xt1 - xt3)^2, (xt3 - xt2)^2), mean)] 
                colnames(res) <- c("theta_12", "theta_13", "theta_23")
                res[, c("t", "delta_index", "delta") := .(dt[1, t2], dt[1, delta_index], dt[1, delta])]
                return(res)
            }
        )
    )
    # $\widehat{H_t} = \frac{\log \left( \widehat{\theta}(t_1, t_3) \right) - \log \left( \widehat{\theta}(t_1, t_2) \right)}{2 \log(2)}$
    reg_dt[, H := (log(theta_13) - log(theta_12)) / (2 * log(2))] 
    # $\widehat{L_t} = \frac{\widehat{\theta}(t_1, t_3)}{\Delta^{2 \widehat{H_t}}}$
    reg_dt[, L := theta_13 / (delta^(2 * H))] 
    return(reg_dt)
}
\end{minted}

\section{Détermination des risques}

\begin{minted}[linenos=true, mathescape=true, frame=single, breaklines]{R}
risk_eucl_dt <- function(N, lbd, sm_method) {
    base_path <- "/home/hbrunet/pfe-hugo-brunet/no_pkg/"
    reg_path <- "regularity/"       # régularité $\widehat{H_t}   | \widehat{\theta}(u,v) = \frac{1}{N} \sum_i (\widehat{X}_i(v) - \widehat{X}_i(u))^2$
    treg_path <- "regularity_true/" # régularité $\widetilde{H_t} | \widetilde{\theta}(u,v) = \frac{1}{N} \sum_i ( X_i(v) - X_i(u))^2 $

    for (m in 1:200) {
        reg_file <- glue::glue("reg_N{N}_lbd{lbd}_logistic_{sm_method}_mc{m}.rds")
        treg_file <- glue::glue("regtrue_N{N}_lbd{lbd}_logistic_{sm_method}_mc{m}.rds")

        rg <- readRDS(glue::glue(base_path, reg_path, reg_file))
        trg <- readRDS(glue::glue(base_path, treg_path, treg_file))

        rg_t <- split(rg, by = "t")
        trg_t <- split(trg, by = "t")

        w_mc <- rbindlist(lapply(names(rg_t), function(t_v) {
            u <- rg_t[[t_v]]
            v <- trg_t[[t_v]]

            e_12_13 <- (u[, theta_12] - v[, theta_12])^2 + (u[, theta_13] - v[, theta_13])^2
            e_13_23 <- (u[, theta_13] - v[, theta_13])^2 + (u[, theta_23] - v[, theta_23])^2
            e_12_23 <- (u[, theta_12] - v[, theta_12])^2 + (u[, theta_23] - v[, theta_23])^2

            data.table(
                t = u[, t],
                delta = u[, delta],
                eucl_12_13 = e_12_13,
                eucl_13_23 = e_13_23,
                eucl_12_23 = e_12_23
            )
        }))
        w_mc[, mc := m]
        if (m == 1) {
                w <- w_mc
            } else {
                w <- rbind(w, w_mc)
                rm(w_mc)
            }
    }
}

# Création des tables de risques avec aggregation des multiples simulations de Monte-Carlo :
r_dt_lbd <- readRDS(...) # table des risques calculées précédemment

#  $\theta_{12} : \theta(t_1, t_2)$ + $\theta_{13} = \theta(t_1, t_3)$

r_dt_12_13 <- r_dt_lbd[, .(
    mean(eucl_12_13), 
    median(eucl_12_13), 
    var(eucl_12_13), 
    mad(eucl_12_13), 
    quantile(eucl_12_13, 0.05), 
    quantile(eucl_12_13, 0.25), 
    quantile(eucl_12_13, 0.75), 
    quantile(eucl_12_13, 0.95)
    ), by = .(t, delta) ]
names(r_dt_12_13) <- c("t", "delta", "mean", "median", "var", "mad", "q_05", "q_25", "q_75", "q_95")

# ... similaire pour les autres couples
\end{minted}

\section{Lissage adaptatif}

Dans la subsection \ref{annexe:estim_adapt}, nous avons mentionné qu'il était judicieux de lisser les courbes de façon adaptative à la quantité que l'on souhaite estimer. Si l'on a mentionné le risque à minimiser pour chaque quantité que l'on souhaite estimer, aucun détail n'a été fourni car il alourdit considérablement la trame de l'objectif du stage sans apporter des informations cruciales.

\bigskip

Cependant pour l'implémentation d'un tel lissage adaptatif, il fallait évidemment se référer au détail de l'expression pour pouvoir évaluer ce risque et déterminer la meilleure fenêtre.

\bigskip

\begin{equation*}
    R_\mu( \, t \, , h \, ) =
    \underbracket[0.187ex]{L_t^2 h ^{2H_t} \mathds B( \, t, h, 2H_t \,) }_{\textsf{contrôle du biais}}
    + \underbracket[0.187ex]{\sigma^2 \mathds V_\mu( \, t, h \, ) }_{\textsf{contrôle de la variance}}
    + \underbracket[0.187ex]{\frac{\mathds D_\mu( \, t \, )}{P_N(t, h)}}_{\textsf{contrôle de la dépendance}}
\end{equation*}

Développons maintenant les différentes quantités présentes dans l'expression :

\begin{equation*}
    {\mathds D_\mu( \, t \, )} \isdef
\end{equation*}
\begin{equation*}
    \mathds V_\mu( \, t, h \, ) \isdef
\end{equation*}
\begin{equation*}
    \mathds B( \, t, h, 2H_t \,) \isdef
\end{equation*}
\begin{equation*}
    P_N(t, h) \isdef
\end{equation*}

Dont l'implémentation sous R est la suivante :

\begin{minted}[linenos=true, mathescape=false, frame=single, breaklines]{R}
...
\end{minted}
\fi
